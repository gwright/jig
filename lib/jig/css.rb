
require 'jig'

class Jig
  # Jig::CSS is a subclass of Jig designed to facilitate the construction of CSS rulesets.
  # This class should be considered experimental.
  #
  # An instance of Jig::CSS represents a CSS rule consisting of a selector list 
  # and an associated declaration block.  The selector list or the delcaration block
  # or both may be empty.
  #
  # A simple CSS type selector with an empty declaration is the default construction:
  #
  #   C.div           # => "div {}"
  #   C.li            # => "li {}"
  #
  # The universal selector is generated by #us
  #
  #   C.us            # => "* {}"
  #
  # Rules are represented by a hash and can be added to any css jig with the 'or'
  # operator.
  #
  #   big = { 'font-size' => '24pt' }
  #   bold = { 'font-weight' => 'bold' }
  #   bigger = C.div | big                # => div {font-size: 24pt; }
  #   bolder = bigger | bold              # => div {font-size: 24pt; font-weight: bold; }
  #
  # The or operator can also combine selectors:
  #
  #   C.h1 | C.h2                    # => h1, h2 { }
  #   C.h1 | big | C.h2 | bold       # => h1, h2 { font-size: 24pt; font-weight: bold; }
  #
  # The last selector in a selector jig can be transformed by a variety of operators:
  #
  #   C.h1.urgent                     # => h1.urgent {}
  #   C.span.example.sample           # => span.example.sample {}
  #
  #   C.
  class CSS < Jig
    module IntegerHelper
      def in; "#{self}in"; end
      def cm; "#{self}cm"; end
      def mm; "#{self}mm"; end
      def pt; "#{self}pt"; end
      def pc; "#{self}pc"; end
      def em; "#{self}em"; end
      def ex; "#{self}ex"; end
      def px; "#{self}px"; end
      def pct; "#{self}%"; end
    end

    module FloatHelper
      def pct; "%.2f%%" % (self*100); end
    end

    Integer.class_eval { include IntegerHelper }
    Float.class_eval { include FloatHelper }

    Newlines = [:html, :head, :body, :title, :div, :p, :table, :script, :form]
    Encode = Hash[*%w{& amp " quot > gt < lt}]

    class <<self
      alias __new :new
    end

    Rule = __new(:__s, " {", :__ds, :__de, "}").freeze

    class <<self

      def new(selector=nil, plist=nil)
        Rule | selector | plist
      end

      def to_declarations(hash)
        hash.inject(Jig.null) do |djig, (property, value)| 
          djig.push(
            case value
              when Gap
                value
              when Symbol
                Gap.new(value) { |fill| declaration(property, fill) }
              else
                declaration(property, value)
            end
          )
        end
      end

      # Convert property/value pair for use in a CSS rule jig.
      # 
      def declaration(property, value)
        case value
        when nil, false
          ""
        when Symbol
          Gap.new(value) { |fill| declaration(property, fill) }
        when Gap
          value
        when Jig
          Jig.new { declaration(property, value.to_s) }
        when Proc, Method
          Jig.new { declaration(property, value.call) }
        when Array
          seperator = (property == 'font-family' ? ", " : " ")
          declaration(property, value.join(seperator))
        else
          property = property.to_s.tr('_','-')
          "#{property}: #{value}; "
        end
      end

      # Generate a universal selector rule
      def us(*args)
        new('*', *args)
      end

      def merge(*selectors)
        selectors.inject {|list, sel| list.merge(sel) }
      end

      def method_missing(sym, *args)
        new(sym.to_s, *args)
      end
    end

    # Construct a child selector.  The parent is the lhs selector and
    # the child is the rhs selector.
    # 
    #   (div > p)     # => "div > p {}"
    def >(other)
      before(:__s, " > ", other.selector).before(:__de, other.declarations)
    end

    # Construct an adjacent sibling selector.  The first sibling is 
    # the lhs selector and the other sibling is rhs selector.
    # 
    #   h1 + p     # => "h1 + p {}"
    def +(other)
      before(:__s, " + ", other.selector).before(:__de, other.declarations)
    end

    # Construct an id selector.  The id is the rhs value.
    # 
    #   h1 * 'chapter-one'     # => "h1#chapter-one {}"
    def *(id)
      before(:__s, "#", id.to_s)
    end

    # Construct a pseudo-selector.
    #
    #   h1/:first_letter      # => "h1:first-letter {}"
    #   a/:active             # => "a:active {}"
    def /(pseudo)
      before(:__s, ":", pseudo.to_s)
    end

    # Construct a descendent selector.  The parent is the lhs selector and
    # the descendent is the rhs selector.
    # 
    #   div >> p     # => "div p {}"
    def >>(other)
      before(:__s, " ", other.selector).before(:__de, other.declarations)
    end

    # Merge this selector with another object. If the other object is a
    # hash, the hash is converted to a CSS declaration list and merged
    # with the current list. If the other object is a rule, the other
    # selectors and declarations are merged with the current selectors
    # and declarations. Any other object is assumed to be a selector
    # string and is merged with the current selectors.
    #
    # div.merge(:color => 'red')    # => div { color: red; }
    # div.merge(h1)                 # => div, h1 {}
    # div.merge('h1, h2, h3')       # => div, h1, h2, h3 {}
    def merge(other)
      return self unless other
      sep = selector.null? ? "" : ", "
      case other
      when Hash
        before(:__de, self.class.to_declarations(other)) 
      when self.class
        before(:__s, sep, other.selector).plug(:__de, other.declarations)
      else
        before(:__s, sep, other)
      end
    end

    alias | :merge

    # Extract the selector list from the rule as a jig.
    #   (div | h1).selector     # => Jig["div, h1"]
    def selector
      self.class.__new(slice(0))
    end

    # Extract the declaration list from the rule.  The list is returned as
    # a jig and not as a hash.
    #   div(:color => 'red').declarations   # => Jig["color: red; ", :__de]
    def declarations
      s,e = index(:__ds),index(:__de)
      self.class.__new(slice((s+1)..e))
    end

    # Transform missing methods into class selectors. 
    #   div.urgent        # => div.urgent {}
    #   div.note.caution  # => div.note.caution {}
    def method_missing(sym, plist=nil)
      with_class(sym, plist)
    end

    # Add a class selector to pending selector.  Usually
    # this method is called indirectly via method_missing.
    #
    #   div.with_class('urgent')        # => div.urgent {}
    def with_class(klass, plist=nil)
      before(:__s, ".#{klass}") | plist
    end

    # Construct an attribute selector. If the argument is a
    # simple string a simple attribute selector is constructed. If
    # the argument is a hash with a string as the value, an exact
    # attribute selector is constructed.  If the value is a regular 
    # expression, a partial attribute selector is constructed. If 
    # the key is the literal string 'lang', a language attribute 
    # selector is constructed.
    #
    #   input[:type]                # => input[type] {}
    #   input[:type => 'password']  # => input[type="password"] {}
    #   input[:lang => 'en']        # => input[lang|="en"] {}
    #   input[:class => /heading/]  # => input[class=~"heading"] {}
    def [](*args)
      if args.size == 1 && args.first.respond_to?(:to_hash) && args.first.size == 1
        k,v = *args.first.to_a.first
        case v
        when String
          before(:__s, %Q{[#{k}="#{v}"]})
        when Regexp
          v = v.to_s.split(':').last.chop    # strip out the processing flags
          if k.to_s == 'lang'
            before(:__s, %Q{[lang|="#{v}"]})
          else
            before(:__s, %Q{[#{k}~="#{v}"]})
          end
        else
          self
        end
      elsif args.size == 1 && args.first.respond_to?(:to_s)
        before(:__s, "[#{args.first}]")
      else
        self
      end
    end

  end
end
